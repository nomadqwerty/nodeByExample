const events =  require('events')

// The 'error' events that are generated by the captureRejections behavior do not have a catch handler to avoid infinite error loops: the recommendation is to not use async functions as 'error' event handlers.
// captureRejections <boolean> It enables automatic capturing of promise rejection. Default: false.

events.captureRejections=true
const {EventEmitter,errorMonitor} = events

// events are used when a callback needs to be executed multiple times

// instance of event emmitter class
const myEmmitter = new EventEmitter()

// attach an event listerner with .on() or .addListener()
myEmmitter.on('signal',(data)=>{
    // run cb f(n) when signal is detected
    // the this key word doesnt point to the EventEmiiter but rather the instance inwhich .on() was used
    setImmediate(()=>{
        // eventemitter are usaully synchronius to ensure code runs sequentially and to avoid race conditions and logic error
        
        // switch between sync and async using setImmediate. this tells takes it off the thread of execution and moves it to the eventloop to be handled async
        console.log('async evnt listener')
    })
    setTimeout(()=>{
        console.log('times execution')
    },1000)
    console.log('recieved',data,this==EventEmitter,this === myEmmitter);
})
console.log('on');

myEmmitter.once('signal',()=>{
    console.log('happens once')
})
// similate an signal BC
// can pass additional params into emit()
myEmmitter.emit('signal','hello')


// can make the listener respond once to an event
// setInterval(() => {
    //   myEmmitter.emit('signal','hi')  
    // }, 1000);    
// handle errors in events. every instance of the EventEmitter has an error event and a registered callback
// listen for error and return errors , this keeps node process alive
myEmmitter.on('error',(error)=>{
    console.log('ok')
})
// we can monitor error with errorMonitor, this fails to catch error. process still crashes
myEmmitter.on(errorMonitor,(error)=>{
    console.log(error.message)
})

myEmmitter.emit('error',new Error('error found'))

// use async callback in event listener
// this is risky it can lead to unhandled rejections
const ee = new EventEmitter({captureRejections:true})

ee.on('error',async(value)=>{
    throw new Error('kaboom')
})

ee.on('error',console.log)

// EventEmiiter class
// the event emiiter class is exposed by the events module
// all E.E(eventemitters), emit a 'newListener' event when new listener is added. and 'removeListener' when listeners are removed

// event: 'newListener'
// E.E has an internal array of all listeners. before a new listener is added to the array it emits the event.

// aListener=>event:'signal', E.E adds the listener and registers its event attach.

const listena = new EventEmitter()

// 'newListener' event simulation
// listen for newly registered eventlistenrs
listena.once('newListener',(event,listener)=>{
    console.log('there is a new listener')
    if(event==='event'){
        console.log(event)
        listena.on('event',()=>{
            console.log('B')
        })
    }
})


listena.on('event',()=>{
    console.log("A")
})

listena.emit('event')

// removeListener event. similar to newListener. it emitts this event b4 an eventlistener is removed from the E.E internal array

// emitter.on is an eventListener that waits for the registered event to be emiited

// emitter.emit('eventToEmitt',args...)
// .emit is used to emit the event. it synch calls are callbacks with the registered events
const synchCalls = new EventEmitter()

synchCalls.on('emitted',()=>{
    console.log('im num 1')
})
synchCalls.on('emitted',(a,b)=>{
    console.log(a,b)
})
        
synchCalls.emit('emiited',1,2)


// emiiter.eventNames
// lists an array or reqistered events: of Type: str,sym
const myEE = new EventEmitter()
myEE.on('thisShit',()=>{

})
console.log(myEE.eventNames())